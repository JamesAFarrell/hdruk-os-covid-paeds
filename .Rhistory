plot_boot_coef = table_boot_coef %>%
filter(var_name == "(Intercept)") %>%
ggplot(aes(x= var_name, y = coef_min)) +
geom_boxplot()
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= var_name, y = coef_min)) +
geom_boxplot()
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= coef_min, y = var_name)) +
geom_boxplot()
plot_boot_coef
table_boot_coef = table_boot_coef %>%
mutate(
var_name = var_name %>% factor(levels = unique(var_name)) %>%
fct_rev()
)
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= coef_min, y = var_name)) +
geom_boxplot()
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= exp(coef_min), y = var_name)) +
geom_boxplot()
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= exp(coef_min), y = var_name)) +
geom_boxplot(colour = "blue")
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= exp(coef_min), y = var_name)) +
geom_boxplot(fill = "blue")
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= exp(coef_min), y = var_name)) +
geom_boxplot(fill = "green")
plot_boot_coef
plot_boot_coef = table_boot_coef %>%
filter(var_name != "(Intercept)") %>%
ggplot(aes(x= exp(coef_min), y = var_name)) +
geom_boxplot(fill = "green") +
theme_bw()
plot_boot_coef
# Load packages ----
library(tidyverse)
library(lubridate)
# Load custom functions and lookup tables ----
source(here::here("analysis", "00_utility_functions.R"))
# Output directories ----
dir.create(here::here("output", "data"),
showWarnings = FALSE, recursive=TRUE)
dir.create(here::here("output", "descriptives", "positives_resource_use"),
showWarnings = FALSE, recursive=TRUE)
# Load global variables ----
global_var = jsonlite::read_json(path = here::here("analysis", "global_variables.json"))
# Study dates ----
study_start_date = ymd(global_var$start_date)
study_end_date   = ymd(global_var$end_date)
tp_start_date    = ymd(global_var$tp_start_date)
tp_end_date      = ymd(global_var$tp_end_date)
fup_start_date   = ymd(global_var$fup_start_date)
# Load patient data ----
data_patient    = read_rds(here::here("output", "data", "data_patient.rds"))
# Create inclusion flowchart data ----
data_inclusion = data_patient %>%
transmute(
patient_id,
tested_positive = covid_status_tp == "Positive",
not_nosocomial = covid_nosocomial == "No",
no_discrepant_results = covid_discrepant_test == "No"
)
# Filter out non-positives and not aged 4 to 17 inclusive ----
data_positives = data_patient %>%
filter(covid_status_tp == "Positive",
covid_nosocomial == "No",
covid_discrepant_test == "No")
data_positives = data_positives %>%
calc_indexed_variables(data_positives %>% pull(covid_test_date_pos_tp)) %>%
apply_exclusion_criteria()
# Load packages ----
library(tidyverse)
library(lubridate)
library(finalfit)
# Load custom functions and lookup tables ----
source(here::here("analysis", "00_utility_functions.R"))
# Output directories ----
dir.create(here::here("output", "data"),
showWarnings = FALSE, recursive=TRUE)
dir.create(here::here("output", "descriptives", "positives_resource_use"),
showWarnings = FALSE, recursive=TRUE)
# Load global variables ----
global_var = jsonlite::read_json(path = here::here("analysis", "global_variables.json"))
# Study dates ----
study_start_date = ymd(global_var$start_date)
study_end_date   = ymd(global_var$end_date)
tp_start_date    = ymd(global_var$tp_start_date)
tp_end_date      = ymd(global_var$tp_end_date)
fup_start_date   = ymd(global_var$fup_start_date)
# Load patient data ----
data_patient    = read_rds(here::here("output", "data", "data_patient.rds"))
# Create inclusion flowchart data ----
data_inclusion = data_patient %>%
transmute(
patient_id,
tested_positive = covid_status_tp == "Positive",
not_nosocomial = covid_nosocomial == "No",
no_discrepant_results = covid_discrepant_test == "No"
)
# Filter out non-positives and not aged 4 to 17 inclusive ----
data_positives = data_patient %>%
filter(covid_status_tp == "Positive",
covid_nosocomial == "No",
covid_discrepant_test == "No")
data_positives = data_positives %>%
calc_indexed_variables(data_positives %>% pull(covid_test_date_pos_tp)) %>%
apply_exclusion_criteria()
## Update inclusion data ----
data_inclusion = data_inclusion %>%
left_join(
data_positives %>%
transmute(
patient_id,
meets_age_criteria = TRUE
),
by = "patient_id"
) %>%
replace_na(list(meets_age_criteria = FALSE))
# Create inclusion flowchart ----
flowchart = data_inclusion %>%
transmute(
patient_id,
c0 = TRUE,
c1 = c0 & tested_positive,
c2 = c1 & not_nosocomial,
c3 = c2 & no_discrepant_results,
c4 = c3 & meets_age_criteria,
) %>%
select(-patient_id) %>%
summarise(
across(.fns=sum)
) %>%
mutate(
pivot_col = "pivot"
) %>%
pivot_longer(
cols=-pivot_col,
names_to="criteria",
values_to="n"
) %>%
select(-pivot_col) %>%
mutate(
n = n #%>% plyr::round_any(count_round)
) %>%
mutate(
n_exclude = lag(n) - n,
pct_all = (n/first(n)) %>% scales::percent(0.1),
pct_exclude_step = (n_exclude/lag(n)) %>% scales::percent(0.1),
crit = str_extract(criteria, "^c\\d+"),
criteria = fct_case_when(
crit == "c0" ~ "OpenSAFELY extract: Registered with GP, alive, with age >0 and <18 years on 01 January 2019",
crit == "c1" ~ "-  Positive SARS-CoV-2 RT-PCR test during testing period",
crit == "c2" ~ "-  with no probable nosocomial infection",
crit == "c3" ~ "-  with no same-day discrepant RT-PCR test result",
crit == "c4" ~ "-  with age between 4 and 17 years inclusive on test/matched date",
TRUE ~ NA_character_
)
) %>%
mutate(n_exclude = n_exclude %>% as.character()) %>%
replace_na(
list(n_exclude = "-", pct_exclude_step = "-")
)
## Format flowchart table ----
tbl_flowchart = flowchart %>%
select(criteria, n, n_exclude, pct_all, pct_exclude_step)
## Save flowchart table ----
write_csv(tbl_flowchart,
here::here("output", "descriptives", "positives_resource_use",
"tbl_flowchart.csv"))
# Load resource data and filter patient id ----
data_admissions = read_rds(here::here("output", "data", "data_admissions.rds")) %>%
filter(patient_id %in% data_positives$patient_id)
data_outpatient = read_rds(here::here("output", "data", "data_outpatient.rds")) %>%
filter(patient_id %in% data_positives$patient_id)
data_gp = read_rds(here::here("output", "data", "data_gp.rds"))  %>%
filter(patient_id %in% data_positives$patient_id)
# Filter out specialty specific/non-contact code types ----
## Outpatient ----
data_outpatient = data_outpatient %>%
filter(is.na(specialty))
## GP ----
data_gp = data_gp %>%
filter(str_starts(code_type, "KM_") | str_starts(code_type, "mapped_1_"))
# Calculate start and end of follow-up
data_positives = data_positives %>%
mutate(
follow_up_start_date = covid_test_date_pos_tp + days(15),
follow_up_end_date   = follow_up_start_date   + days(364)
)
# Resource dataset ----
## Create template ----
data_resource = data_positives %>%
group_by(patient_id) %>%
summarise(
date = seq(follow_up_start_date, follow_up_end_date, "day"),
date_indexed = 1:365,
alive = date < death_date
) %>%
ungroup() %>%
replace_na(list(alive = TRUE))
## Admissions -----
### Filter for dates during 1-year follow-up (starts 14 days after test date) ----
data_admissions = data_admissions %>%
left_join(
data_positives %>%
select(patient_id, follow_up_start_date, follow_up_end_date),
by = "patient_id"
) %>%
filter(admission_date >= follow_up_start_date,
admission_date <= follow_up_end_date)
### Bed-days ----
data_resource = data_resource %>%
left_join(
data_admissions %>%
select(patient_id, admission_date, discharge_date, follow_up_end_date) %>%
rowwise() %>%
mutate(date = list(seq(admission_date, discharge_date, by = "day"))) %>%
unnest(date) %>%
ungroup() %>%
mutate(n_beddays = case_when(
date == admission_date ~ 0.5,
date == discharge_date ~ 0.5,
TRUE ~ 1
)) %>%
select(patient_id, date, n_beddays),
by = c("patient_id", "date")
)
### Critical-care ----
data_resource = data_resource %>%
left_join(
data_admissions %>%
filter(critical_care_days > 0) %>%
select(patient_id, index, admission_date, discharge_date, follow_up_end_date, critical_care_days) %>%
rowwise() %>%
mutate(date = list(seq(admission_date,
min(admission_date + days((critical_care_days)), discharge_date),
by = "day"))) %>%
unnest(date) %>%
ungroup() %>%
group_by(patient_id, index) %>%
mutate(n_critical_care = case_when(
row_number() == 1 ~ 0.5,
row_number() == n() ~ 0.5,
TRUE ~ 1
)) %>%
ungroup() %>%
select(patient_id, date, n_critical_care),
by = c("patient_id", "date")
)
## Outpatient ----
data_resource = data_resource %>%
left_join(
data_outpatient %>%
left_join(
data_positives %>%
select(patient_id, follow_up_start_date, follow_up_end_date),
by = "patient_id"
) %>%
filter(outpatient_date >= follow_up_start_date,
outpatient_date <= follow_up_end_date) %>%
rename(date = outpatient_date, n_outpatient = outpatient_count) %>%
select(patient_id, date, n_outpatient),
by = c("patient_id", "date")
)
## GP ----
data_resource = data_resource %>%
left_join(
data_gp %>%
left_join(
data_positives %>%
select(patient_id, follow_up_start_date, follow_up_end_date),
by = "patient_id"
) %>%
filter(gp_date >= follow_up_start_date,
gp_date <= follow_up_end_date) %>%
filter(str_starts(code_type, "KM_") |
str_starts(code_type, "mapped_1") |
str_starts(code_type, "mapped_2")) %>%
distinct(patient_id, gp_date, .keep_all = TRUE) %>%
mutate(n_gp = 1) %>%
select(patient_id, date = gp_date, n_gp),
by = c("patient_id", "date")
)
# Fix N/A values ----
data_resource = data_resource %>%
replace_na(
list(alive = TRUE,
n_beddays = 0,
n_critical_care = 0,
n_outpatient = 0,
n_gp = 0))
# Save resource data ----
write_rds(data_resource,
here::here("output", "data", "data_resource.rds"),
compress="gz")
# Save positive cohort data ----
write_rds(data_positives,
here::here("output", "data", "data_positives.rds"),
compress="gz")
here::here("output", "lcmm")
# Load data - assumes data is in dummy data format .rds
resource    <- readRDS(here::here("output", "data", "data_resource.rds"))
#===============================================================================
# Script: LCMM.R
# Objective: Cluster trajectory of healthcare service usage using LCMM Clustering
# Last Edited by : Karthik Mohan, 6 Oct 2022
#===============================================================================
rm(list=ls())
#================================= Packages ====================================
# Load packages ----
library(tidyverse)
library(cowplot)
library(lcmm)
library(finalfit)
library(knitr)
library(splines2)
# require('LCTMtools')
# lapply(pkgs, require, character.only = TRUE)
getwd()
# setwd('SLICK/SLICK_R/')
# =============================================================================
# Insert appropriate data path
output_path = here::here("output", "lcmm")
path_model  = here::here("output", "lcmm", "models")
# Create output folders
dir.create(output_path, showWarnings = FALSE, recursive=TRUE)
dir.create(path_model,  showWarnings = FALSE, recursive=TRUE)
# Load data - assumes data is in dummy data format .rds
resource = readRDS(here::here("output", "data", "data_resource.rds"))
#===============================================================================
# Some preprocessing for resource RDS
# Create list of patients
id_list = unique(resource$patient_id)
# Create used service column
resource <- resource %>%
mutate(service = case_when(n_critical_care > 0 ~ 'CC',
n_beddays > 0 & n_critical_care == 0 ~ 'BD',
n_outpatient > 0 & (n_beddays == 0 & n_critical_care == 0) ~ 'OP',
n_gp > 0 & (n_critical_care == 0 & n_outpatient == 0 & n_beddays == 0) ~ 'Contact',
n_gp == 0 & n_critical_care == 0 & n_outpatient == 0 & n_beddays == 0 ~ 'None')
)
# list of services (5)
service_list = unique(resource$service)
resource <- resource %>%
mutate(hospital = case_when(service %in% c('CC','BD','OP') ~ 1,
service %in% c('Contact','None') ~ 0)) %>%
mutate(month = lubridate::month(date)) %>%
group_by(patient_id) %>%
mutate(indexed_month = dense_rank(month))
resource_agg <- resource %>%
group_by(patient_id, indexed_month) %>%
summarise(hospital_use = sum(hospital))
resource_agg <- as.data.frame(resource_agg)
#=============================== Functions =====================================
# Set model parameters ----
max_ng = 5     # Maximum number of clusters
max_iter = 2000 # Maximum number of iterations
iter_save = 25  # Number of iterations after which model is saved
m_degree = 3
m_knots = 7
# Run lcmm loop across number of clusters ----
for(ng in 1:max_ng){
if (ng == 1){
print('Entered iteration for ng == 1')
lcmm_model = hlme(hospital_use~bSpline(indexed_month, degree=3, knots=7),
random=~bSpline(indexed_month, degree=3, knots=7),
subject='patient_id',
ng=ng,
maxiter=max_iter,
data=resource_agg,
verbose = FALSE)
B = lcmm_model
}
else{
print(paste0('Entered iteration for ng == ', ng))
lcmm_model = hlme(fixed = hospital_use~bSpline(indexed_month, degree=3, knots=7),
random= ~bSpline(indexed_month, degree=3, knots=7),
mixture = ~bSpline(indexed_month, degree=3, knots=7),
classmb = ~1,
ng = ng,
B = B,
data = resource_agg,
subject = "patient_id",
maxiter = iter_save,
verbose = FALSE)
}
print(paste0('Iteration for ng = ',ng, ' completed.'))
}
View(resource_agg)
View(resource)
source(here::here("analysis", "10_MCC_functions.R"))
# Load data ----
resource = readRDS(here::here("output", "data", 'data_resource.rds'))
#===============================================================================
# Script: Trajectory_modelling_MCC
# Objective: Cluster trajectory of healthcare service usage using MCC Clustering
# Last Edited by : Karthik Mohan, 8 Oct 2022
#===============================================================================
rm(list=ls())
# ====================  Packages ===============================================
pkgs <- c("dplyr", "ggplot2", "tidyr", "tidyverse")
# install.packages(pkgs)
lapply(pkgs, require, character.only = TRUE)
# ================== Path ======================================================
# Define output directories ----
dir_test_run        = here::here("output", "MCC", "test_run")
dir_model_selection = here::here("output", "MCC", "model_selection")
# Create output directories ----
dir.create(dir_test_run,        showWarnings = FALSE, recursive=TRUE)
dir.create(dir_model_selection, showWarnings = FALSE, recursive=TRUE)
# Load data ----
resource = readRDS(here::here("output", "data", 'data_resource.rds'))
# Source files ----
source(here::here("analysis", "10_entropy_fix.R"))
source(here::here("analysis", "10_MCC_functions.R"))
# Current priority Crit > Bed > OP > Contact; but does this make sense? Trajectory can change in one day
# Critical Care never occurs in isolation (in this dataset)
# Create label for service used in day based on priority outlined above
resource <- resource %>%
mutate(service = case_when(n_critical_care > 0 ~ 'CC',
n_beddays > 0 & n_critical_care == 0 ~ 'BD',
n_outpatient > 0 & (n_beddays == 0 & n_critical_care == 0) ~ 'OP',
n_gp > 0 & (n_critical_care == 0 & n_outpatient == 0 & n_beddays == 0) ~ 'Contact',
n_gp == 0 & n_critical_care == 0 & n_outpatient == 0 & n_beddays == 0 ~ 'None')
)
# 5 - Critical Care
levels = c('None', 'Contact', 'OP', 'BD', 'CC')
resource <- resource %>% mutate(service_idx = as.numeric(factor(service, levels=levels)))
# Create lagged service column to calculate transition frequency matrix
resource <- resource %>%
group_by(patient_id) %>%
mutate(prev_service_idx = lag(service_idx, n = 1, default = NA)) %>%
mutate(prev_service_idx = tidyr::replace_na(prev_service_idx, 1))
n = length(unique(resource$patient_id))
# Initial State Vector
initial_state_vector <- resource$service_idx[which(resource$date_indexed==1)]
# Transitions vectors
tr_list <- vector("list", length = n)
patient_list <- unique(resource$patient_id)
for (i in 1:n){
tr_list[[i]] <- as.integer(resource$service_idx[which(resource$patient_id == patient_list[i])]-1) #added -1
}
njki <- dataListToNjki(tr_list)
max_groupNr <- 8
results <- list()
# Loop through for each cluster number k
for (groupNr in 1:max_groupNr){
results[[groupNr]] <- MCClust(
Data = list(
dataFile = njki, ## Transition frequency matrix
storeDir = myOutfilesDir, # Outpath
priorFile = NULL), # whether priors are supplied in external file
Prior = list(H = groupNr, # number of clusters
e0 = 4, # Determines the value of the prior parameter of the Dirichlet-prior for the group sizes h
c = 1, # used for calculating prior parameter mx  ---- ONLY WHEN PRIORFILE = FALSE
cOff = 1, # used for calculating prior parameter mx ---- ONLY WHEN PRIORFILE = FALSE
usePriorFile = FALSE, # prior info for transition probabilities provided as priorfile
xiPooled = FALSE, # set true only if priorfile = True
N0 = 5), # Determines a parameter for use in calculating the prior parameter matrix
Initial = list(xi.start.ind = 3,
pers = 0.7,
S.i.start = as.integer(initial_state_vector)),
Mcmc = list(M = 150,
M0 = 30,
mOut = 50,
mSave = 10,
seed = 1234))
}
# Loop through for each cluster number k
for (groupNr in 1:max_groupNr){
results[[groupNr]] <- MCClust(
Data = list(
dataFile = njki, ## Transition frequency matrix
storeDir = dir_test_run, # Outpath
priorFile = NULL), # whether priors are supplied in external file
Prior = list(H = groupNr, # number of clusters
e0 = 4, # Determines the value of the prior parameter of the Dirichlet-prior for the group sizes h
c = 1, # used for calculating prior parameter mx  ---- ONLY WHEN PRIORFILE = FALSE
cOff = 1, # used for calculating prior parameter mx ---- ONLY WHEN PRIORFILE = FALSE
usePriorFile = FALSE, # prior info for transition probabilities provided as priorfile
xiPooled = FALSE, # set true only if priorfile = True
N0 = 5), # Determines a parameter for use in calculating the prior parameter matrix
Initial = list(xi.start.ind = 3,
pers = 0.7,
S.i.start = as.integer(initial_state_vector)),
Mcmc = list(M = 150,
M0 = 30,
mOut = 50,
mSave = 10,
seed = 1234))
}
modelSel(workDir=dir_test_run, myLabel = "model choice for ...",
H0 = 3,
whatToDoList =c("approxMCL", "approxML", "postMode"))
results[[1]]
