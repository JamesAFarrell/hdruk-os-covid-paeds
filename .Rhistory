# Written by: Karthik Mohan, James Farrell
#
# Load packages ----
library(tidyverse)
# Load custom functions ----
source(here::here("analysis", "10_0_MCC_functions.R"))
# Command arguments to set number of clusters ----
args = commandArgs(trailingOnly=TRUE)
if(length(args) == 0){
n_clusters = 5 # will hard code n_clusters = 3 to 8 in .yaml
} else{
n_clusters = args[[1]]
}
# Directories ----
dir_mcc_model      = here::here("output", "mcc", "model")
## Create output directories ----
dir.create(dir_mcc_model,      showWarnings = FALSE, recursive=TRUE)
# Load data ----
data_resource = read_rds(here::here("output", "data", "data_resource_mcc.rds"))
# Pre-processing for resource data ----
levels=c('None', 'Contact', 'OP', 'BD', 'CC')
data_resource <- data_resource %>% mutate(service_idx = as.numeric(factor(service, levels=levels)))
# Create lagged service column to calculate transition frequency matrix
resource <- data_resource %>%
group_by(patient_id) %>%
mutate(prev_service_idx = lag(service_idx, n = 1, default = NA)) %>%
mutate(prev_service_idx = tidyr::replace_na(prev_service_idx, 1))
# Initial State Vector
initial_state_vector <- resource$service_idx[which(resource$date_indexed==1)]
# Transitions vectors
id_list = unique(data_resource$patient_id)
n = length(id_list)
tr_list <- vector("list", length = n)
for (i in 1:n){
tr_list[[i]] <- as.integer(resource$service_idx[which(resource$patient_id == id_list[i])]-1) #added -1
}
njki <- dataListToNjki(tr_list)
# ==============================================================================
max_groupNr <- n_clusters # KM: upper bound of clusters to be tested. e.g. if 5, then clusters 1 to 5 will be tested
results <- list()
# Loop through for each cluster number k
# Creates n_clusters number of model results in dir_mcc_model
for (groupNr in 1:max_groupNr){
results[[groupNr]] <- MCClust(
Data = list(
dataFile = njki, ## Transition frequency matrix
storeDir = dir_mcc_model, # Outpath
priorFile = NULL), # whether priors are supplied in external file
Prior = list(H = groupNr, # number of clusters
e0 = 4, # Determines the value of the prior parameter of the Dirichlet-prior for the group sizes h
c = 1, # used for calculating prior parameter mx  ---- ONLY WHEN PRIORFILE = FALSE
cOff = 1, # used for calculating prior parameter mx ---- ONLY WHEN PRIORFILE = FALSE
usePriorFile = FALSE, # prior info for transition probabilities provided as priorfile
xiPooled = FALSE, # set true only if priorfile = True
N0 = 5), # Determines a parameter for use in calculating the prior parameter matrix
Initial = list(xi.start.ind = 3,
pers = 0.7,
S.i.start = as.integer(initial_state_vector)),
Mcmc = list(M = 150,
M0 = 30,
mOut = 50,
mSave = 10,
seed = 1234))
}
# Studying the Long-term Impact of COVID-19 in Kids (SLICK)
#
# 10_MCC_model.R
# Centre for Medical Informatics, Usher Institute, University of Edinburgh 2022
# School of Informatics, University of Edinburgh 2022
# Written by: Karthik Mohan, James Farrell
#
# Load packages ----
library(tidyverse)
# Load custom functions ----
source(here::here("analysis", "10_0_MCC_functions.R"))
# Command arguments to set number of clusters ----
args = commandArgs(trailingOnly=TRUE)
if(length(args) == 0){
n_clusters = 5 # will hard code n_clusters = 3 to 8 in .yaml
} else{
n_clusters = args[[1]]
}
# Directories ----
dir_mcc_model      = here::here("output", "mcc", "model")
## Create output directories ----
dir.create(dir_mcc_model,      showWarnings = FALSE, recursive=TRUE)
# Load data ----
data_resource = read_rds(here::here("output", "data", "data_resource_mcc.rds"))
# Pre-processing for resource data ----
levels=c('None', 'Contact', 'OP', 'BD', 'CC')
data_resource <- data_resource %>% mutate(service_idx = as.numeric(factor(service, levels=levels)))
# Create lagged service column to calculate transition frequency matrix
resource <- data_resource %>%
group_by(patient_id) %>%
mutate(prev_service_idx = lag(service_idx, n = 1, default = NA)) %>%
mutate(prev_service_idx = tidyr::replace_na(prev_service_idx, 1))
# Initial State Vector
initial_state_vector <- resource$service_idx[which(resource$date_indexed==1)]
# Transitions vectors
id_list = unique(data_resource$patient_id)
n = length(id_list)
tr_list <- vector("list", length = n)
for (i in 1:n){
tr_list[[i]] <- as.integer(resource$service_idx[which(resource$patient_id == id_list[i])]-1) #added -1
}
njki <- dataListToNjki(tr_list)
# ==============================================================================
max_groupNr <- n_clusters # KM: upper bound of clusters to be tested. e.g. if 5, then clusters 1 to 5 will be tested
results <- list()
# Loop through for each cluster number k
# Creates n_clusters number of model results in dir_mcc_model
for (groupNr in 1:max_groupNr){
results[[groupNr]] <- MCClust(
Data = list(
dataFile = njki, ## Transition frequency matrix
storeDir = dir_mcc_model, # Outpath
priorFile = NULL), # whether priors are supplied in external file
Prior = list(H = groupNr, # number of clusters
e0 = 4, # Determines the value of the prior parameter of the Dirichlet-prior for the group sizes h
c = 1, # used for calculating prior parameter mx  ---- ONLY WHEN PRIORFILE = FALSE
cOff = 1, # used for calculating prior parameter mx ---- ONLY WHEN PRIORFILE = FALSE
usePriorFile = FALSE, # prior info for transition probabilities provided as priorfile
xiPooled = FALSE, # set true only if priorfile = True
N0 = 5), # Determines a parameter for use in calculating the prior parameter matrix
Initial = list(xi.start.ind = 3,
pers = 0.7,
S.i.start = as.integer(initial_state_vector)),
Mcmc = list(M = 150,
M0 = 30,
mOut = 50,
mSave = 10,
seed = 1234))
}
# Creates 3 R workspace files with model selection criterion based on whatToDoList
# Also creates a .csv with model selection criteria
modelSel(workDir=dir_mcc_model, myLabel = "model choice for ...",
H0 = 3,
whatToDoList =c("approxMCL", "approxML", "postMode"))
# Studying the Long-term Impact of COVID-19 in Kids (SLICK)
#
# 10_MCC_model.R
# Centre for Medical Informatics, Usher Institute, University of Edinburgh 2022
# School of Informatics, University of Edinburgh 2022
# Written by: Karthik Mohan, James Farrell
#
# Load packages ----
library(tidyverse)
# Load custom functions ----
source(here::here("analysis", "10_0_MCC_functions.R"))
# Command arguments to set number of clusters ----
args = commandArgs(trailingOnly=TRUE)
if(length(args) == 0){
n_clusters = 5 # will hard code n_clusters = 3 to 8 in .yaml
} else{
n_clusters = args[[1]]
}
# Directories ----
dir_mcc_model      = here::here("output", "mcc", "model")
## Create output directories ----
dir.create(dir_mcc_model,      showWarnings = FALSE, recursive=TRUE)
# Load data ----
data_resource = read_rds(here::here("output", "data", "data_resource_mcc.rds"))
# Pre-processing for resource data ----
levels=c('None', 'Contact', 'OP', 'BD', 'CC')
data_resource <- data_resource %>% mutate(service_idx = as.numeric(factor(service, levels=levels)))
# Create lagged service column to calculate transition frequency matrix
resource <- data_resource %>%
group_by(patient_id) %>%
mutate(prev_service_idx = lag(service_idx, n = 1, default = NA)) %>%
mutate(prev_service_idx = tidyr::replace_na(prev_service_idx, 1))
# Initial State Vector
initial_state_vector <- resource$service_idx[which(resource$date_indexed==1)]
# Transitions vectors
id_list = unique(data_resource$patient_id)
n = length(id_list)
tr_list <- vector("list", length = n)
for (i in 1:n){
tr_list[[i]] <- as.integer(resource$service_idx[which(resource$patient_id == id_list[i])]-1) #added -1
}
njki <- dataListToNjki(tr_list)
# ==============================================================================
max_groupNr <- n_clusters # KM: upper bound of clusters to be tested. e.g. if 5, then clusters 1 to 5 will be tested
results <- list()
# Loop through for each cluster number k
# Creates n_clusters number of model results in dir_mcc_model
for (groupNr in 1:max_groupNr){
results[[groupNr]] <- MCClust(
Data = list(
dataFile = njki, ## Transition frequency matrix
storeDir = dir_mcc_model, # Outpath
priorFile = NULL), # whether priors are supplied in external file
Prior = list(H = groupNr, # number of clusters
e0 = 4, # Determines the value of the prior parameter of the Dirichlet-prior for the group sizes h
c = 1, # used for calculating prior parameter mx  ---- ONLY WHEN PRIORFILE = FALSE
cOff = 1, # used for calculating prior parameter mx ---- ONLY WHEN PRIORFILE = FALSE
usePriorFile = FALSE, # prior info for transition probabilities provided as priorfile
xiPooled = FALSE, # set true only if priorfile = True
N0 = 5), # Determines a parameter for use in calculating the prior parameter matrix
Initial = list(xi.start.ind = 3,
pers = 0.7,
S.i.start = as.integer(initial_state_vector)),
Mcmc = list(M = 150,
M0 = 30,
mOut = 50,
mSave = 10,
seed = 1234))
}
# Creates 3 R workspace files with model selection criterion based on whatToDoList
# Also creates a .csv with model selection criteria
modelSel(workDir=dir_mcc_model, myLabel = "model choice for ...",
H0 = 3,
whatToDoList =c("approxMCL", "approxML", "postMode"))
#===============================================================================
# Script: Trajectory_modelling_MCC - Visualization
# Objective: Visualize transition probabilities within clusters of MCC Clustering
# Last Edited by : Karthik Mohan, 8 Oct 2022
#===============================================================================
rm(list=ls())
library(tidyverse)
library(ggplot2)
# Load functions
source(here::here("analysis", "10_0_MCC_functions.R"))
# Directories ----
dir_mcc_plot       = here::here("output", "mcc", "plots")
dir_mcc_alloc       = here::here("output", "mcc", "allocations")
dir_mcc_model = here::here("output","mcc","model")
## Create output directories ----
dir.create(dir_mcc_plot, showWarnings = FALSE, recursive=TRUE)
dir.create(dir_mcc_alloc, showWarnings = FALSE, recursive=TRUE)
model_selection = read.csv(here::here("output", "mcc", "model", "model_selection_criteria.csv"))
#===============================================================================
# Select best cluster based on selection criteria
best_cluster = as.integer(names(which.max(table(apply(model_selection,2,which.min)))))
files = list.files(dir_mcc_model)
model_name = files[which.max(sapply(X=files, FUN=grep, pattern=paste0("H",best_cluster)))]
# Get class allocations for best clustering
load(paste0(dir_mcc_model,'/',model_name),temp_env <- new.env())
selected_model = as.list(temp_env)   # Insert path for selected model here
thin = 1
maxi = 50
M0 = selected_model$Mcmc$M0
plotPathsForEta = TRUE
op <- calcAllocationsMCC(selected_model,
thin = thin,
maxi = maxi,
M0 = M0,
plotPathsForEta = plotPathsForEta)
class_allocation_file_name = paste0(dir_mcc_alloc, model_name, '_class_allocations','.csv')
write.csv(x = op$classProbs, file = class_allocation_file_name)
#===============================================================================
# Work with results
# Visualize transition probabilities per group
results <- selected_model
remove(selected_model)
estTransProb <- results$estTransProb
# Reshape the 3D array of results to long dataframe for ggplot
df <- as.data.frame(estTransProb) %>% #dataframe
rownames_to_column('InitState') %>% # get initial state as column
gather('Group', value, -InitState) %>% # convert to long format by group
mutate(Group = gsub('.Group',' ',Group)) %>% # some processing to separate group name and transition state
separate(Group, c("TransState","Group")) %>%
mutate(
InitState = factor(InitState, levels=0:4),  # converting to factors
TransState = factor(TransState, levels=0:4)
)
# relabel factor levels
df$InitState <- recode_factor(df$InitState, `0` = 'None',`1`='Contact',`2`='OP',`3`='Bed',`4`='CC')
df$TransState <- recode_factor(df$TransState, `0` = 'None',`1`='Contact',`2`='OP',`3`='Bed',`4`='CC')
# facet heatmap for transition probabilities
ggplot(df, aes(TransState, InitState)) +
geom_tile(aes(fill = value)) +
geom_text(aes(label = round(value, 2))) +
scale_fill_gradient(low = "white", high = "green") +
facet_grid(rows=vars(Group))
ggsave(paste0(dir_mcc_plot, model_name, format(Sys.time(), "%Y%m%d_%H%M%S"),'_plot.png'))
#===============================================================================
dir_mcc_alloc
class_allocation_file_name
# facet heatmap for transition probabilities
plot_heatmap = ggplot(df, aes(TransState, InitState)) +
geom_tile(aes(fill = value)) +
geom_text(aes(label = round(value, 2))) +
scale_fill_gradient(low = "white", high = "green") +
facet_grid(rows=vars(Group))
ggsave(filename = here::here("output", "mcc", "heatmap.jpeg"),
plot = plot_heatmap,
width = 7, height = 7, units = "in")
op$classProbs
op$class
list.files("output/mcc/model/")
#===============================================================================
# Script: Trajectory_modelling_MCC - Visualization
# Objective: Visualize transition probabilities within clusters of MCC Clustering
# Last Edited by : Karthik Mohan, 8 Oct 2022
#===============================================================================
rm(list=ls())
library(tidyverse)
library(ggplot2)
# Load functions
source(here::here("analysis", "10_0_MCC_functions.R"))
# Directories ----
dir_mcc_plot       = here::here("output", "mcc", "plots")
dir_mcc_alloc       = here::here("output", "mcc", "allocations")
dir_mcc_model = here::here("output","mcc","model")
## Create output directories ----
dir.create(dir_mcc_plot, showWarnings = FALSE, recursive=TRUE)
dir.create(dir_mcc_alloc, showWarnings = FALSE, recursive=TRUE)
model_selection = read.csv(here::here("output", "mcc", "model", "model_selection_criteria.csv"))
#===============================================================================
# Select best cluster based on selection criteria
best_cluster = as.integer(names(which.max(table(apply(model_selection,2,which.min)))))
files = list.files(dir_mcc_model)
model_name = files[which.max(sapply(X=files, FUN=grep, pattern=paste0("H",best_cluster)))]
# Get class allocations for best clustering
load(paste0(dir_mcc_model,'/',model_name),temp_env <- new.env())
selected_model = as.list(temp_env)   # Insert path for selected model here
thin = 1
maxi = 50
M0 = selected_model$Mcmc$M0
plotPathsForEta = TRUE
op <- calcAllocationsMCC(selected_model,
thin = thin,
maxi = maxi,
M0 = M0,
plotPathsForEta = plotPathsForEta)
write_csv(op$classProbs,
here::here("output", "mcc", "allocations", "allocations.csv"))
write_csv(op$classProbs %>% as_tibble,
here::here("output", "mcc", "allocations", "allocations.csv"))
op$classProbs
write_csv(op$classProbs %>% as.data.frame(),
here::here("output", "mcc", "allocations", "allocations.csv"))
# Load packages ----
library(tidyverse)
# List all csv files ---
list_files = list.files(
here::here("output", "descriptives", "healthcare_use_2019_2022", "monthly_tables"),
pattern = "*.csv")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map_df(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
)
}, .id = "set_id")
View(monthly_count_summarised)
View(monthly_count_summarised)
?map
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
)
}, .id = "set_id")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
) %>%
mutate(set_id = file)
})
View(monthly_count_summarised)
# Load packages ----
library(tidyverse)
# List all csv files ---
list_files = list.files(
here::here("output", "descriptives", "healthcare_use_2019_2022", "monthly_tables"),
pattern = "*.csv")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
) %>%
mutate(set_id = file)
})
# List all csv files ---
list_files = list.files(
here::here("output", "descriptives", "healthcare_use_2019_2022", "monthly_tables"),
pattern = "*.csv")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map_df(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
)
}, .id = "set_id")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map_df(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 100)
)
}, .id = "set_id")
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file),
col_types = rep("c", 13)
)
})
monthly_count_summarised[[1]]
x =  monthly_count_summarised %>%
bind_rows()
# Load and aggregate csv files ----
monthly_count_summarised = list_files %>%
map_df(function(file){
monthly_count = read_csv(
here::here("output", "descriptives", "healthcare_use_2019_2022",
"monthly_tables", file)
) %>%
mutate(across(.cols = everything(), as.character))
})
View(monthly_count_summarised)
# Load custom functions and lookup tables ----
source(here::here("analysis", "00_utility_functions.R"))
# Load global variables ----
global_var = jsonlite::read_json(path = here::here("analysis", "global_variables.json"))
# Studying the Long-term Impact of COVID-19 in Kids (SLICK)
#
# 11_DTW_tsclust.R
# Centre for Medical Informatics, Usher Institute, University of Edinburgh 2022
# School of Informatics, University of Edinburgh 2022
# Written by: Karthik Mohan, James Farrell
#
# This script determines patient clusters based on time series clustering of
# healthcare resource use during the follow-up period.
# Load packages ----
library(tidyverse)
library(lubridate)
library(dtwclust)
# Load function files ----
source(here::here("analysis", "11_0_DTW_functions.R"))
# Command arguments to set number of clusters ----
args = commandArgs(trailingOnly=TRUE)
if(length(args) == 0){
n_clusters = 7
} else{
n_clusters = args[[1]] %>% as.integer()
}
# Load data ----
data_resource = read_rds(here::here("output", "data", "data_resource_dtw.rds"))
# Create output directories ----
dir.create(here::here("output", "dtw", "tsclust"),      showWarnings = FALSE, recursive=TRUE)
dir.create(here::here("output", "dtw", "cv_indicies"),  showWarnings = FALSE, recursive=TRUE)
dir.create(here::here("output", "dtw", "data_cluster"), showWarnings = FALSE, recursive=TRUE)
# Pre-processing for resource data ----
## Create list of patients ----
id_list = unique(data_resource$patient_id)
## List of services (5) -----
service_list = levels(data_resource$service)
# Run the function (map to patient group in df) ----
id_resource_seq = data_resource %>%
group_by(patient_id) %>%
group_map(~get_indv_resource_traj(.x, .y$patient_id))
names(id_resource_seq) = map(id_resource_seq, attr, "name")
attr(id_resource_seq, "service_list") = service_list
regist_dist()
# Perform time series clustering ----
ts_cluster = tsclust(series = id_resource_seq,
k = n_clusters,
distance = "dtw_basic",
type = "partitional",
seed = 43)
# Reinterpolate to same length
series <- reinterpolate(CharTraj, new.length = max(lengths(CharTraj)))
## Save time series clustering ----
write_rds(ts_cluster,
here::here("output", "dtw", "tsclust",
paste0("tsclust_", n_clusters, ".rds")))
# Cluster validity indicies ----
cvi_extract = cvi(ts_cluster)
## Make into table ----
tbl_cv_indicies = tibble(
n_cluster = ts_cluster@k,
converged = ts_cluster@converged,
cv_index  = names(cvi_extract),
cv_value  = cvi_extract
)
## Save cluster validity table
write_csv(tbl_cv_indicies,
here::here("output", "dtw", "cv_indicies",
paste0("tbl_cv_indicies_", n_clusters, ".csv")))
# Save cluster assignments ----
data_cluster = tibble(
patient_id = ts_cluster@datalist %>% names() %>% as.integer(),
cluster    = ts_cluster@cluster
)
## Save cluster assignments ----
write_rds(data_cluster,
here::here("output", "dtw", "data_cluster",
paste0("data_cluster_", n_clusters, ".rds")))
summary(ts_cluster)
?tsclust
plot(ts_cluster)
service_list
